package com.broadtech.analyse.flink.process.cmcc;

import com.broadtech.analyse.pojo.cmcc.*;
import org.apache.flink.api.common.state.*;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.functions.co.BroadcastProcessFunction;
import org.apache.flink.util.Collector;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author jiangqingsong
 * @description
 * @date 2020-06-09 16:11
 */
public class AgentMatchVulnerabilityProcess extends BroadcastProcessFunction<AssetAgentOrigin, Map<String, Vulnerability>, Tuple2<AssetAgentOrigin, String>> {
    MapStateDescriptor<Void, Map<String, Vulnerability>> configDescriptor;

    public AgentMatchVulnerabilityProcess(MapStateDescriptor configDescriptor) {
        this.configDescriptor = configDescriptor;
    }

    @Override
    public void processElement(AssetAgentOrigin agent, ReadOnlyContext ctx, Collector<Tuple2<AssetAgentOrigin, String>> out) throws Exception {
        long t0 = System.currentTimeMillis();
        ReadOnlyBroadcastState<Void, Map<String, Vulnerability>> broadcastState = ctx.getBroadcastState(this.configDescriptor);
        Map<String, Vulnerability> vulnerabilityMap = broadcastState.get(null);
        if(vulnerabilityMap != null){
            //待检测漏洞的Tuple<name, version>列表
            List<Tuple2<String, String>> toCheckList = new ArrayList<>();
            List<ProgramInfo> programInfos = agent.getProgramInfos();
            List<MessageOrientedMiddleware> messageOrientedMiddlewares = agent.getMessageOrientedMiddlewares();
            List<DataBaseInfo> dataBaseInfos = agent.getDataBaseInfos();
            for(ProgramInfo p: programInfos){
                toCheckList.add(Tuple2.of(p.getName(), p.getVersion()));
            }
            for(MessageOrientedMiddleware m: messageOrientedMiddlewares){
                toCheckList.add(Tuple2.of(m.getName(), m.getVersion()));
            }
            for(DataBaseInfo d: dataBaseInfos){
                toCheckList.add(Tuple2.of(d.getName(), d.getVersion()));
            }

            Set<String> products = vulnerabilityMap.keySet();
            for(Tuple2<String, String> tuple: toCheckList){
                String name = tuple.f0;
                String version = tuple.f1;
                boolean isExist = false;
                String title = "";
                String productOut = "";
                for(String product: products){
                    if(product.contains(name)){
                        isExist = true;
                        title = vulnerabilityMap.get(product).getTitle();
                        productOut = product;
                        break;
                    }
                }
                //可以考虑多个漏洞多条记录输出
                if(isExist){
                    out.collect(Tuple2.of(agent, vulnerabilityMap.get(productOut).getNumber()));
                    //out.collect(name + ": 疑似漏洞！" + title );
                }else {
                    //out.collect(name + ": 非漏洞！");
                    out.collect(Tuple2.of(agent, Vulnerability.createInstance().getNumber()));
                }
            }
            long t1 = System.currentTimeMillis();
            System.out.println("耗时： " + (t1 - t0));
        }
    }

    /**
     * 更新配置流状态
     * @param value
     * @param ctx
     * @param out
     * @throws Exception
     */
    @Override
    public void processBroadcastElement(Map<String, Vulnerability> value, Context ctx, Collector<Tuple2<AssetAgentOrigin, String>> out) throws Exception {
        System.out.println("==== Enter broadcast stream to update vulnerability.====");
        BroadcastState<Void, Map<String, Vulnerability>> broadcastState = ctx.getBroadcastState(this.configDescriptor);
        broadcastState.clear();
        broadcastState.put(null, value);
    }

}
