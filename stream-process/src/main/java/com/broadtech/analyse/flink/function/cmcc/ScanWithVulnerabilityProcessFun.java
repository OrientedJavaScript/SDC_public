package com.broadtech.analyse.flink.function.cmcc;

import com.broadtech.analyse.pojo.cmcc.*;
import com.broadtech.analyse.pojo.main.CNVDVulnerability;
import com.mysql.cj.jdbc.Driver;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.tuple.Tuple3;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;
import org.apache.log4j.Logger;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.*;

/**
 * @author leo.J
 * @description 漏洞匹配
 * @date 2020-06-11 17:15
 */
public class ScanWithVulnerabilityProcessFun extends ProcessFunction<AssetScanOrigin, Tuple2<AssetScanOrigin, String>> {
    private static Logger LOG = Logger.getLogger(ScanWithVulnerabilityProcessFun.class);
    private static final OutputTag<Tuple2<AssetAgentOrigin, String>> vulnerabilityTag
            = new OutputTag<Tuple2<AssetAgentOrigin, String>>("VulnerabilityTag") {};
    private static final OutputTag<Tuple2<AssetAgentOrigin, String>> labelTag
            = new OutputTag<Tuple2<AssetAgentOrigin, String>>("labelTag") {};

    private Connection connection = null;
    private PreparedStatement ps1 = null;
    private volatile boolean isRunning = true;

    private String jdbcUrl;
    private String userName;
    private String password;

    private Map<String, CNVDVulnerability> valnerabilityMap;
    private Map<String, Tuple3<Integer, String, String>> labelMap;

    private Timer timer;
    public ScanWithVulnerabilityProcessFun(String jdbcUrl, String userName, String password) {
        this.jdbcUrl = jdbcUrl;
        this.userName = userName;
        this.password = password;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        valnerabilityMap = new HashMap<>();
        //开启一个定时任务，定期更新配置数据
        timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                try {
                    getData();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, 1000, 1*30*60*1000);
    }

    @Override
    public void close() throws Exception {
        timer.cancel();
        timer = null;
    }

    /**
     * 获取漏洞数据和label数据
     * @throws Exception
     */
    public void getData() throws Exception{
        DriverManager.registerDriver(new Driver());
        connection = DriverManager.getConnection(jdbcUrl, userName, password);//获取连接
        String sql1 = "select * from brd_cnvd_vulnerability";
        ps1 = connection.prepareStatement(sql1);

        if (isRunning) {
            ResultSet rs1 = ps1.executeQuery();
            while (rs1.next()) {
                String number = rs1.getString("number");
                String cve_number = rs1.getString("cve_number");
                String cve_url = rs1.getString("cve_url");
                String title = rs1.getString("title");
                String serverity = rs1.getString("serverity");
                String product = rs1.getString("product");
                String is_event = rs1.getString("is_event");
                String submittime = rs1.getString("submit_time");
                String opentime = rs1.getString("open_time");
                String reference_link = rs1.getString("reference_link");
                String formalway = rs1.getString("formalway");
                String description = rs1.getString("description");
                String patchname = rs1.getString("patchname");
                String patch_description = rs1.getString("patch_description");

                //String discoverername = rs1.getString("discoverername");
                if("".equals(product)){
                    continue;
                }

                CNVDVulnerability vulnerability = new CNVDVulnerability();
                //Vulnerability vulnerability = new Vulnerability();
                vulnerability.setNumber(number);
                vulnerability.setCveNumber(cve_number);
                vulnerability.setCveUrl(cve_url);
                vulnerability.setTitle(title);
                vulnerability.setServerity(serverity);
                vulnerability.setProduct(product);
                vulnerability.setIsEvent(is_event);
                vulnerability.setSubmitTime(submittime);
                vulnerability.setOpenTime(opentime);
                vulnerability.setReferenceLink(reference_link);
                vulnerability.setFormalway(formalway);
                vulnerability.setDescription(description);
                vulnerability.setPatchName(patchname);
                vulnerability.setPatchDescription(patch_description);
                valnerabilityMap.put(product, vulnerability);
            }
            LOG.info("====== valnerabilityMap size ======" + valnerabilityMap.size());
            System.out.println("====== valnerabilityMap size ======" + valnerabilityMap.size());
        }

    }

    @Override
    public void processElement(AssetScanOrigin scan, Context context, Collector<Tuple2<AssetScanOrigin, String>> out) throws Exception {
        if(valnerabilityMap != null){
            //待检测漏洞的Tuple<name, version>列表
            List<Tuple2<String, String>> toCheckList = new ArrayList<>();
            List<MessageOrientedMiddlewareScan> messageOrientedMiddlewares = scan.getMessageOrientedMiddleware();
            List<DataBaseInfoScan> dataBaseInfos = scan.getDataBaseInfos();
            List<OpenServiceOfPort> openServiceOfPorts = scan.getOpenServiceOfPort();

            for(OpenServiceOfPort o: openServiceOfPorts){
                toCheckList.add(Tuple2.of(o.getName(), o.getVersion()));
            }

            for(MessageOrientedMiddlewareScan m: messageOrientedMiddlewares){
                toCheckList.add(Tuple2.of(m.getName(), m.getVersion()));
            }
            for(DataBaseInfoScan d: dataBaseInfos){
                toCheckList.add(Tuple2.of(d.getName(), d.getVersion()));
            }
            toCheckList.add(Tuple2.of(scan.getOSInfo(), ""));
            toCheckList.add(Tuple2.of(scan.getResourceName(), ""));
            toCheckList.add(Tuple2.of(scan.getSystemFingerprintInfo(), ""));
            toCheckList.add(Tuple2.of(scan.getRuning(), ""));

            Set<String> products = valnerabilityMap.keySet();

            boolean isExist = false;
            Set<String> matchedVulnerabilitySet = new HashSet<>();
            for(Tuple2<String, String> tuple: toCheckList){
                if("".equals(tuple.f0)){
                    continue;
                }
                String name = tuple.f0;
                String version = tuple.f1;
                boolean isCurrentExist = false;
                String productOut = "";
                for(String product: products){
                    if(product.contains(name)){
                        isCurrentExist = true;
                        productOut = product;
                        break;
                    }
                }
                //可以考虑多个漏洞多条记录输出
                if(isCurrentExist){
                    isExist = true;
                    matchedVulnerabilitySet.add(valnerabilityMap.get(productOut).getNumber());
                }
            }
            if(!isExist){
                out.collect(Tuple2.of(scan, ""));
            }else {
                String separator = ",";
                out.collect(Tuple2.of(scan, StringUtils.join(matchedVulnerabilitySet, separator)));
            }
        }
    }
}
