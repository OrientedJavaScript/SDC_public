package com.broadtech.analyse.flink.function.cmcc;

import com.broadtech.analyse.pojo.cmcc.*;
import com.mysql.jdbc.Driver;
import org.apache.commons.lang3.StringUtils;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.tuple.Tuple3;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.*;

/**
 * @author jiangqingsong
 * @description
 * @date 2020-06-11 17:15
 */
public class AgentWithVulnerabilityProcessFun extends ProcessFunction<AssetAgentOrigin, Tuple2<AssetAgentOrigin, String>> {
    private Connection connection = null;
    private PreparedStatement ps1 = null;
    private volatile boolean isRunning = true;

    private String jdbcUrl;
    private String userName;
    private String password;

    private Map<String, Vulnerability> valnerabilityMap;
    private Map<String, Tuple3<Integer, String, String>> labelMap;
    private Timer timer;
    public AgentWithVulnerabilityProcessFun(String jdbcUrl, String userName, String password) {
        this.jdbcUrl = jdbcUrl;
        this.userName = userName;
        this.password = password;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        valnerabilityMap = new HashMap<>();
        //开启一个定时任务，定期更新配置数据
        timer = new Timer(true);
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                try {
                    getData();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }, 1000, 1*30*60*1000);
    }

    @Override
    public void close() throws Exception {
        timer.cancel();
        timer = null;
    }
    /**
     * 获取漏洞数据和label数据
     * @throws Exception
     */
    public void getData() throws Exception{
        DriverManager.registerDriver(new Driver());
        connection = DriverManager.getConnection(jdbcUrl, userName, password);//获取连接
        String sql1 = "select * from vulnerability";
        ps1 = connection.prepareStatement(sql1);

        if (isRunning) {
            ResultSet rs1 = ps1.executeQuery();
            while (rs1.next()) {
                String description = rs1.getString("description");
                String discoverername = rs1.getString("discoverername");
                String formalway = rs1.getString("formalway");
                String isevent = rs1.getString("isevent");
                String number = rs1.getString("number");
                String opentime = rs1.getString("opentime");
                String patchdescription = rs1.getString("patchdescription");
                String patchname = rs1.getString("patchname");
                String product = rs1.getString("product");
                String serverity = rs1.getString("serverity");
                String submittime = rs1.getString("submittime");
                String title = rs1.getString("title");
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setDescription(description);
                vulnerability.setDiscoverername(discoverername);
                vulnerability.setFormalway(formalway);
                vulnerability.setIsevent(isevent);
                vulnerability.setNumber(number);
                vulnerability.setOpentime(opentime);
                vulnerability.setPatchdescription(patchdescription);
                vulnerability.setPatchname(patchname);
                vulnerability.setServerity(serverity);
                vulnerability.setSubmittime(submittime);
                vulnerability.setTitle(title);
                vulnerability.setProduct(product);
                valnerabilityMap.put(product, vulnerability);
            }
        }

    }

    @Override
    public void processElement(AssetAgentOrigin agent, Context context, Collector<Tuple2<AssetAgentOrigin, String>> out) throws Exception {
        if(valnerabilityMap != null){
            //待检测漏洞的Tuple<name, version>列表
            List<Tuple2<String, String>> toCheckList = new ArrayList<>();
            List<ProgramInfo> programInfos = agent.getProgramInfos();
            List<MessageOrientedMiddleware> messageOrientedMiddlewares = agent.getMessageOrientedMiddlewares();
            List<DataBaseInfo> dataBaseInfos = agent.getDataBaseInfos();
            for(ProgramInfo p: programInfos){
                toCheckList.add(Tuple2.of(p.getName(), p.getVersion()));
            }
            for(MessageOrientedMiddleware m: messageOrientedMiddlewares){
                toCheckList.add(Tuple2.of(m.getName(), m.getVersion()));
            }
            for(DataBaseInfo d: dataBaseInfos){
                toCheckList.add(Tuple2.of(d.getName(), d.getVersion()));
            }

            Set<String> products = valnerabilityMap.keySet();

            boolean isExist = false;
            Set<String> matchedVulnerabilitySet = new HashSet<>();
            for(Tuple2<String, String> tuple: toCheckList){
                if("".equals(tuple.f0)){
                    continue;
                }
                String name = tuple.f0;
                String version = tuple.f1;
                boolean isCurrentExist = false;
                String productOut = "";
                for(String product: products){
                    if(product.contains(name)){
                        isCurrentExist = true;
                        productOut = product;
                        break;
                    }
                }
                //可以考虑多个漏洞多条记录输出
                if(isCurrentExist){
                    isExist = true;
                    matchedVulnerabilitySet.add(valnerabilityMap.get(productOut).getNumber());
                }
            }
            if(!isExist){
                out.collect(Tuple2.of(agent, ""));
            }else {
                String separator = ",";
                out.collect(Tuple2.of(agent, StringUtils.join(matchedVulnerabilitySet, separator)));
            }
        }
        //agent\login不做漏洞匹配
        //out.collect(Tuple2.of(agent, ""));
    }
}
